<!DOCTYPE html>
<html>
<head>
  <meta charset="utf-8">
  
  <title>IOS学习笔记——斯坦福公开课笔记 | null</title>
  <meta name="viewport" content="width=device-width, initial-scale=1, maximum-scale=1">
  <meta name="description" content="IOS学习笔记，基于斯坦福公开课基于swift的IOS 9 App开发。">
<meta property="og:type" content="article">
<meta property="og:title" content="IOS学习笔记——斯坦福公开课笔记">
<meta property="og:url" content="http://www.loongeek.com/2016/06/15/IOS学习笔记——斯坦福公开课笔记/index.html">
<meta property="og:site_name">
<meta property="og:description" content="IOS学习笔记，基于斯坦福公开课基于swift的IOS 9 App开发。">
<meta property="og:image" content="http://www.loongeek.com/images/Lecture 2 Slides.jpg">
<meta property="og:updated_time" content="2016-07-06T15:52:58.000Z">
<meta name="twitter:card" content="summary">
<meta name="twitter:title" content="IOS学习笔记——斯坦福公开课笔记">
<meta name="twitter:description" content="IOS学习笔记，基于斯坦福公开课基于swift的IOS 9 App开发。">
  
    <link rel="alternative" href="atom.xml" title="null" type="application/atom+xml">
  
  
    <link rel="icon" href="/favicon.png">
  
  <link href="//fonts.googleapis.com/css?family=Source+Code+Pro" rel="stylesheet" type="text/css">
  <link rel="stylesheet" href="/css/style.css" type="text/css">
  

</head>
<body>
  <div id="container">
    <div id="wrap">
      <header id="header">
  <div id="banner"></div>
  <div id="header-outer" class="outer">
    <div id="header-title" class="inner">
      <h1 id="logo-wrap">
        <a href="/" id="logo">null</a>
      </h1>
      
        <h2 id="subtitle-wrap">
          <a href="/" id="subtitle">Loongeek’s Blog</a>
        </h2>
      
    </div>
    <div id="header-inner" class="inner">
      <nav id="main-nav">
        <a id="main-nav-toggle" class="nav-icon"></a>
        
          <a class="main-nav-link" href="/">首页</a>
        
          <a class="main-nav-link" href="/archives">存档</a>
        
          <a class="main-nav-link" href="/about">关于</a>
        
      </nav>
      <nav id="sub-nav">
        
          <a id="nav-rss-link" class="nav-icon" href="atom.xml" title="RSS Feed"></a>
        
        <a id="nav-search-btn" class="nav-icon" title="Search"></a>
      </nav>
      <div id="search-form-wrap">
        <form action="//google.com/search" method="get" accept-charset="UTF-8" class="search-form"><input type="search" name="q" results="0" class="search-form-input" placeholder="Search"><button type="submit" class="search-form-submit">&#xF002;</button><input type="hidden" name="sitesearch" value="http://www.loongeek.com"></form>
      </div>
    </div>
  </div>
</header>
      <div class="outer">
        <section id="main"><article id="post_catalog-IOS学习笔记——斯坦福公开课笔记" class="article article-type-post_catalog" itemscope itemprop="blogPost">
  <div class="article-meta">
    <a href="/2016/06/15/IOS学习笔记——斯坦福公开课笔记/" class="article-date">
  <time datetime="2016-06-14T16:00:00.000Z" itemprop="datePublished">2016-06-15</time>
</a>
    
  <div class="article-category">
    <a class="article-category-link" href="/categories/软件/">软件</a>
  </div>

  </div>
  <div class="article-inner">
    
    
      <header class="article-header">
        
  
    <h1 class="article-title" itemprop="name">
      IOS学习笔记——斯坦福公开课笔记
    </h1>
  

      </header>
    
    <div class="article-entry" itemprop="articleBody">
      

    <ol class="toc" ><li class="toc-item toc-level-1"><a class="toc-link" href="#第1讲_概述"><span class="toc-text">第1讲 概述</span></a></li><li class="toc-item toc-level-1"><a class="toc-link" href="#第2讲_MVC"><span class="toc-text">第2讲 MVC</span></a></li><li class="toc-item toc-level-1"><a class="toc-link" href="#第3讲_Swift编程以及Foundation框架"><span class="toc-text">第3讲 Swift编程以及Foundation框架</span></a></li><li class="toc-item toc-level-1"><a class="toc-link" href="#第4讲_视图"><span class="toc-text">第4讲 视图</span></a></li><li class="toc-item toc-level-1"><a class="toc-link" href="#第5讲_界面编辑器_手势_多重MVC"><span class="toc-text">第5讲 界面编辑器 手势 多重MVC</span></a></li><li class="toc-item toc-level-1"><a class="toc-link" href="#第6讲_多重MVC_转场_ViewController生命周期"><span class="toc-text">第6讲 多重MVC 转场 ViewController生命周期</span></a></li><li class="toc-item toc-level-1"><a class="toc-link" href="#第7讲_闭包_扩展_协议_代理_ScrollView"><span class="toc-text">第7讲 闭包 扩展 协议 代理 ScrollView</span></a></li><li class="toc-item toc-level-1"><a class="toc-link" href="#第8讲_多线程"><span class="toc-text">第8讲 多线程</span></a></li><li class="toc-item toc-level-1"><a class="toc-link" href="#第9讲_TableView"><span class="toc-text">第9讲 TableView</span></a></li><li class="toc-item toc-level-1"><a class="toc-link" href="#第10讲_Core_Data"><span class="toc-text">第10讲 Core Data</span></a></li><li class="toc-item toc-level-1"><a class="toc-link" href="#第11讲_Core_Data_Demo"><span class="toc-text">第11讲 Core Data Demo</span></a></li><li class="toc-item toc-level-1"><a class="toc-link" href="#第12讲_AutoLayout"><span class="toc-text">第12讲 AutoLayout</span></a></li><li class="toc-item toc-level-1"><a class="toc-link" href="#第13讲_定时器和动画"><span class="toc-text">第13讲 定时器和动画</span></a></li><li class="toc-item toc-level-1"><a class="toc-link" href="#第14讲_动画和运动检测"><span class="toc-text">第14讲 动画和运动检测</span></a></li><li class="toc-item toc-level-1"><a class="toc-link" href="#第15讲_App生命周期_告警_CloudKit"><span class="toc-text">第15讲 App生命周期 告警 CloudKit</span></a></li><li class="toc-item toc-level-1"><a class="toc-link" href="#第16讲_CloudKit和提醒"><span class="toc-text">第16讲 CloudKit和提醒</span></a></li><li class="toc-item toc-level-1"><a class="toc-link" href="#第17讲_转场，Core_Location,_MapKit"><span class="toc-text">第17讲 转场，Core Location, MapKit</span></a></li><li class="toc-item toc-level-1"><a class="toc-link" href="#第18讲_持续化"><span class="toc-text">第18讲 持续化</span></a></li></ol>

        <p>IOS学习笔记，基于斯坦福公开课<strong>基于swift的IOS 9 App开发</strong>。<br><a id="more"></a></p>
<h1 id="第1讲_概述">第1讲 概述</h1><ul>
<li>IOS层次结构(从高层到底层)<ul>
<li>Cocoa Touch:用户交互层</li>
<li>Media: 流和媒体处理</li>
<li>Core Services: 核心业务处理</li>
<li>Core OS:核心操作系统</li>
</ul>
</li>
<li>Core OS: 裁剪版的MacOS, 类Unix操作系统<br>  OS X内核，Mach操作系统, BSD, 文件系统，电源管理，钥匙链访问，证书，Sockets, 安全，Bonjour(无需配置的即时网络功能)</li>
<li>Core Services:<br>  集合，地理位置，地址簿，网络服务，网络，线程，文件访问，配置，SQLite, URL工具</li>
<li>Media:<br>  视频，动画，音频，图片格式处理，OpenGLES, OpenAL, PDF,混音，Quartz(2D显示引擎)，录音</li>
<li>Cocoa Touch:<br>  多点触控，Alert, 运动检测和处理(Core Motion), <code>WebView</code>,<code>View</code>结构，<code>Map Kit</code>, 本地化，Image Picker, 控件，摄像头</li>
<li>开发工具：Xcode, 开发语言：swift,<br>  常用框架：Foundation(in Core Service), UIKit(in Cocoa Touch), Core Data(Core Services),Core Motion(Cocoa Touch),……<br>  设计模式：MVC</li>
<li>可以将不关心的文件移入<code>Supporting Files</code>，保持工程目录简洁</li>
<li>双击<code>View</code>的标题可以自动放大，双击空白处可以自动缩小</li>
<li><code>Scene</code>场景：指的是一个完整的可显示的手机屏幕或者Ipad屏幕</li>
<li><code>AutoLayout</code>的警告：黄色表示显示的框架与约束不符，可以通过<code>Update frames</code>来修正;红色表示有冲突</li>
<li><code>outlet</code>属性是控制器类的<strong>实例变量</strong>，代码窗口中属性旁边的小圆圈可以指示连接到<code>Storyboard</code>的哪个控件</li>
<li>Swift把所有对象都放在堆上</li>
<li><code>println(&quot;\(expr)&quot;)</code>用来打印表达式的值</li>
<li>Swift中，所有的属性都必须初始化，否则需要通过<code>init()</code>来初始化</li>
<li><code>Optional</code>类型：<br>  <code>Type?</code>就是<code>Optional&lt;Type&gt;</code>相当于 <code>Type?Type:nil</code><br>  对于Optional类型，<code>variable!</code>就是解包到实际的Type,如果执行时variable是nil，程序会崩溃</li>
<li>完全支持Unicode，可以使用Emoji字符做为控件图标(实际上是标签)</li>
<li>右键点控件会显示全部Connection</li>
<li>属性分为两种：一种是存储属性(Stored Properties)，一种是计算属性(Computed Properties)。计算属性需要实现<code>get{}</code>,<code>set{}</code></li>
<li><code>switch...case</code>默认带break,不需要添加；可以用<code>fallthrough</code>，也可以用<code>,</code>来表示多个case执行同一分支的情况</li>
<li>闭包(Closure)<pre><code>{ prototype <span class="keyword">in</span>
 xxxx}
</code></pre><ul>
<li>闭包的类型在能够明确推断的情况下，可以省略</li>
<li>$0,$1…可以用来表示参数</li>
<li>原型也可以省略</li>
<li>闭包是最后一个参数的情况下，可以移到括号外：<pre><code>foo<span class="comment">(<span class="doctag"><span class="keyword">xxx</span></span>, closure)</span> 可以写成
foo<span class="comment">(<span class="doctag"><span class="keyword">xxx</span></span>)</span>{}
</code></pre></li>
</ul>
</li>
<li><code>UIButton</code>的<code>currentTitle</code>用来获取当前的标签字串</li>
</ul>
<h1 id="第2讲_MVC">第2讲 MVC</h1><ul>
<li>MVC结构<br><img src="/images/Lecture 2 Slides.jpg" alt="MVC结构"><ul>
<li>Model和Controller交流，View和Controller交流，但是View绝不和Model直接交流</li>
<li>Controller直接控制View, View可以通过多种方式向Controller发出通知：<ul>
<li><code>Target-Action</code>:在Controller中设置Target, 当View接收到指定消息后，通知Target,然后Controller执行Target对应的Action</li>
<li><code>Delegate</code>:代理。Controller是View若干操作的代理，当View执行操作时，将操作权移交给Controller执行，通常是<code>will``did``should</code>等钩子函数。相对于<code>Target-Action</code>，可以切入控制的时间点多，影响的View也变多</li>
<li>Controller直接操作Model, Model可以通过<code>Notification</code>通知广播的方式提醒Controller,也可以让Controller以观察者(KVO,key-value observing)的方式获取Model通知</li>
</ul>
</li>
</ul>
</li>
<li>多重MVC:控制器和控制器相互交流，模型和模型有时可以通过通知或者共享的方式交流，但是视图只能和自己的控制器交流</li>
<li>Swift用<code>[Type]</code>表示数组<code>Array&lt;Type&gt;</code><br>  用<code>[key:value]</code>表示字典<br>  用<code>[xxx,xxx,xxx]</code>表示集（与数组不同，不包含重复成员）,创建时需要显式指定集合类型：<code>var xxx：Set = [xxx,xxx]</code><br>  用<code>(xxx,xxx)</code>表示元组</li>
<li><figure class="highlight"><figcaption><span>A&#123; </span></figcaption><table><tr><td class="gutter"><pre><span class="line">1</span><br></pre></td><td class="code"><pre><span class="line">&#9;case a(Associated Value)&#10;&#9;case b(Associated Value)&#10;&#125;</span><br></pre></td></tr></table></figure>
<p>  使用方法：<code>A.a</code><br>  枚举无法被继承，除此以外与类和结构没有区别<br>  枚举的成员类型可以是任何元组<br>  枚举在赋值时可以同时指定对应的<code>Associated Value</code><br>  枚举在case中用<code>case .XXX(let/var xxx)</code>的方式使用<code>Associated Value</code>。</p>
</li>
<li>Swift中，<code>_</code>的意思不关心这个参数</li>
<li>Swift的访问控制：<ul>
<li><code>private</code>这个类</li>
<li><code>public</code>完全公开</li>
<li><code>internal</code>默认访问权限，仅限本包(Bundle)</li>
</ul>
</li>
<li>enum和struct不能被继承，class可以；<br>  enum和struct是按值传递，class是按引用传递<br>  enum没有初始化，struct和class有</li>
<li>很多类都有<code>description:String</code>用来给出对象的字符串描述</li>
<li>在辅助编辑器中，可以选<code>Generated Interface</code>查看当前类的接口</li>
<li>代码自动缩进<code>⌃I</code></li>
<li>字典和数组取成员操作<code>[]</code>返回的都是<code>Optional</code>类型</li>
<li>结构有一个包含所有参数的默认构造器，类有一个无参的默认构造器</li>
<li><code>⌃⇧+click</code>可以在storyboard中选择当前位置的任一内容，当多个View重叠时很有用</li>
<li><code>String(xxx)</code>转换成字符串，<code>Double(xxx)</code>转换成数值</li>
</ul>
<h1 id="第3讲_Swift编程以及Foundation框架">第3讲 Swift编程以及Foundation框架</h1><ul>
<li><code>Optional</code>本质上是枚举</li>
<li>对于<code>Optional</code>变量，可以用<code>A = XXX ?? &quot;yay&quot;</code>来给一个普通类型赋值，当xxx是nil时赋后面的值</li>
<li>元组<code>(xxx,xxx)</code>,命名元组<code>(xxx:Type,xxx:Type)</code></li>
<li><code>Range</code>范围是一种结构，可以用<code>...</code>或者<code>..&lt;</code>指定闭区间和半闭区间</li>
<li><code>mutating</code>关键字用于表示函数能够改变结构或者枚举参数的内容（一般很少用到？？）</li>
<li><code>typealias</code>指定某种类型的化名，特别适用于闭包的类型</li>
<li><ul>
<li>方法的参数名可以有外部名和内部名，两者默认是一样的</li>
</ul>
</li>
<li>可以<code>override</code>父类的方法，也可以指定方法为<code>final</code>防止被覆盖。<code>final</code>类可以防止被继承</li>
<li>所有属性都支持观察者：<code>willSet</code>和<code>didSet</code>。非常适合用来更新UI</li>
<li><code>lazy var</code>可以在确实使用时才初始化变量,不支持<code>let</code>常量<br>  <code>lazy var a:Type={closure return val}()</code> 用closure来初始化值<br>  <code>lazy var a = self.initA()</code> 若不使用lazy，无法自己初始化自己的变量</li>
<li>数组支持泛型操作<code>filter</code> <code>map</code> <code>reduce</code></li>
<li>字符串分割操作：<code>componentsSeparatedByString|ByCharactersInSet</code></li>
<li>字符串长通过<code>endIndex</code>获取</li>
<li>类初始化:<code>designated</code>必须调超类的初始化，必须在调超类初始化前先初始化所有自己的属性，在这之后初始化超类的属性<br>  <code>convenience</code>只能调自己的其它初始化，而且只有在调完后才能设置属性<br>  初始化的继承：没有实现<code>designated</code>,继承超类的<code>designated</code>;<br>  覆盖了所有<code>designated</code>，继承超类的<code>convenience</code>;<br>  没有实现任何初始化，继承超类的所有初始化<br>  <code>required</code>初始化，子类必须实现(或者继承)</li>
<li><code>init?</code>表明这个初始化返回的是<code>Optional</code></li>
<li><code>AnyObject</code>可以表示任何类，一般用于确实可以容纳各种类的情况，或者不想让调用者知道类型的情况</li>
<li><code>xxx as? Type</code>返回 <code>Type?</code>型的<code>Optional</code>。<code>as!</code>强制解包</li>
<li><code>is</code>判断是否是某个类型</li>
<li>Properties List就是一个AnyObject型的数组<br>  获取：<code>NSUserDefaults.standardUserDefaults()</code><br>  访问：<code>setObject</code> <code>objectForKey</code> <code>arrayForKey</code> <code>setDouble</code> <code>doubleForKey</code> … </li>
<li><code>⌥+click</code>可以显示变量类型</li>
</ul>
<h1 id="第4讲_视图">第4讲 视图</h1><ul>
<li><code>superView</code> <code>subViews</code> <code>addSubView</code> <code>removeFromView</code></li>
<li><code>UIWindow</code> View结构的最顶级，通常一个IOS App只有一个UIWindow</li>
<li>初始化：<code>init(frame:CGRect)</code> 用代码创建时的构造器<br>  <code>init(code: NSCoder)</code> 用storyboard创建时的构造器<br>示例：<pre><code>func setup()<span class="decorator">{...}</span>
override init(frame){
    super.init(frame:frame)
    setup()
}
required init(coder aDecoder: <span class="type">NSCoder</span>){
    super.init(coder:aDecoder)
    setup()
}
</code></pre></li>
<li>视图用的一些数据类型：<code>CGFloat</code> <code>CGPoint</code> <code>CGRect</code> <code>CGSize</code></li>
<li>视图的坐标原点在左上角，右是x正向，下是y正向</li>
<li><code>bounds</code>，视图自身内容的rect，原点是(0,0）,大小是视图自己的大小，不考虑旋转<br>  <code>frame</code> 视图在父视图中的rect</li>
<li>创建View时通常都会产生子类，并修改View的Identity Inspector</li>
<li>自定义视图：重载drawRect()<br>  不要直接调用<code>drawRect</code>，使用<code>setNeedsDisplay()</code> <code>setNeedsDispalyInRect</code>来触发重绘操作</li>
<li>自绘的两种方法：<ul>
<li>使用<code>Core Graphics</code>，类似C的操作：<br>  先通过<code>UIGraphicsGetCurrentContext()</code>获取上下文，然后创建路径，设定笔刷等，最后描线或者填充</li>
<li>使用<code>UIBezierPath</code>, 它会自动在当前上下文中绘制<br>  <code>moveToPoint</code> <code>addLineToPoitn</code> <code>closePath</code><br>  <code>UIColor.xxxColor().setFill()</code><br>  <code>UIColor.xxxColor().setStroke()</code><br>  <code>lineWidth</code> <code>fill()</code> <code>stroke()</code></li>
</ul>
</li>
<li><code>UIBezierPath</code>支持多种基本几何形状。支持剪裁<code>addClip()</code>,支持Hit detection<code>containsPoint</code></li>
<li><code>UIColor</code>支持用图像做为pattern</li>
<li><code>UIColor</code>支持alpha:<code>UIColor.xxColor().colorWithAlphaComponet(xx)</code><br>  但是要使view变成半透明，需要设置：<code>opaque = false</code><br>  也可以指定view的<code>alpha</code>让整个view变透明</li>
<li><code>hidden</code>可以让一个view消失,会影响布局。但不会影响内部的view树状结构</li>
<li>在<code>drawRect</code>中写字：<pre><code><span class="built_in">let</span> <span class="built_in">text</span>=  NSAttributedString<span class="params">(<span class="string">"XXXX"</span>)</span>
<span class="built_in">text</span>.drawAtPoint<span class="params">(XXXX)</span>
<span class="built_in">let</span> textSize: CGSize=  <span class="built_in">text</span>.size
</code></pre></li>
<li><code>NSAttributedString</code>的可修改版本是<code>NSMutableAttributedString</code>,而不像普通字符串那样用let和var区分。需要注意，它既不是NSString也不是String</li>
<li>操作<code>NSMutableAttributedString</code>：<code>setAttributes</code> <code>addAttributes</code><br>  常用属性：<code>NSForegroundColorAttributeName:</code><pre><code><span class="escape">`N</span>SStrokeWidthAttributeName:<span class="escape">`
</span><span class="escape">`N</span>SFontAttributeName:`
</code></pre></li>
<li>建议使用系统默认字体：<br>  <code>preferredFontForTextStyle</code><br>  <code>systemFontOfSize</code> <code>boldSystemFontOfSize</code><br>  这些也可以在Attribute Inspector中选择</li>
<li>通常使用<code>UIImageView</code>来显示图像</li>
<li>创建图像：<code>UIImage(named:)</code>来自资源 <code>UIImage(contentsOfFile: )</code>来自文件  <code>UIImage(data:)</code>来自元数据</li>
<li>画图像：<code>drawAtPoint</code> <code>drawInRect</code> <code>drawAsPatternInRect</code></li>
<li>默认UIView的bounds改变后，它的内容会被拉伸，但不会redraw。需要通过指定<code>contentMode</code>来控制</li>
</ul>
<h1 id="第5讲_界面编辑器_手势_多重MVC">第5讲 界面编辑器 手势 多重MVC</h1><ul>
<li>在View前标注<code>@IBDesignable</code>就可以在界面构建器中直接拖动和控制了，在属性前标注<code>@IBInspectable</code>可以在构建器中调整属性</li>
<li>手势：首先在View中添加手势识别器，然后再提供一个方法处理手势</li>
<li>在View的<code>didSet</code>方法中创建手势识别器比较好，这时View刚刚被ViewController挂载起来<pre><code><span class="preprocessor">@IBOutlet</span> <span class="keyword">weak</span> <span class="keyword">var</span> xxxView: <span class="type">UIView</span>{
    <span class="keyword">didSet</span>{
        <span class="keyword">let</span> recognizer = <span class="type">UIXXXRecognizer</span>(
            target: <span class="keyword">self</span>, action: #selector(<span class="type">FUNCTION</span>)
        )
        xxxView.addGestureRecognizer(recogniser)
    }
}
</code></pre></li>
<li>手势的抽象基类提供<code>state</code>信息：<ul>
<li><code>.Possible</code>手势未开始</li>
<li><code>.Recognized</code> 离散手势</li>
<li><code>.Began</code> <code>.Changed</code> <code>Ended</code> 连续手势</li>
<li><code>Failed</code> <code>Cancelled</code> 异常情况</li>
</ul>
</li>
<li>手势都提供自身的信息查询接口<ul>
<li><code>UIPanGestureRecognizer</code>：translationInView, velocityInView, setTranslation<br>  由于默认是计算当前点和最开始的点的间距，最后一个API可以用来设置当前点为下一次的起始点，以产生增量移动的效果:<code>setTranslation(CGPointZero, curView)</code></li>
<li><code>UIPinchGestureREcognizer</code>: scale, velocity。注意要增量，需要每次把scale设成1</li>
<li><code>UIRotationGestureREcognizer</code>: rotation, velocity</li>
<li><code>UISwipeGestureREcognizer</code>: direction, numberOfTouchesRequired</li>
<li><code>UITapGestureREcognizer</code>: numberOfTapsRequired, numberOfTouchesRequired</li>
</ul>
</li>
<li>三种基本的多重MVC: <code>UITabBarController</code> <code>UISplitViewController</code> <code>UINavigationController</code></li>
<li>tab bar可以通过tabBarItem设定不同的页面</li>
<li>split view有两个窗口master和detail</li>
<li>navigation类型一堆重叠的卡片。它的Controller指向rootViewController（最底层），转场后它会指向最上一层的MVC,<strong>注意：按back返回后最上层的MVC会直接销毁，而其它两种会保留所有的MVC</strong></li>
<li>获取子控制器：<code>viewControllers</code>, tab bar从左到右；split view,[0]=master, [1]=detail; navigation,[0]=root,其它按从下向上</li>
<li>获取父控制器：<code>tabBarController</code> <code>splitViewController</code> <code>navigationController</code></li>
<li>split view只在IPad上正常工作，在iPhone的portraits模式下，无法正常显示，为了正常显示，需要把master view嵌到一个navigation view中，这样在iPhone模式下会自动忽略split view而采用navigation模式</li>
</ul>
<h1 id="第6讲_多重MVC_转场_ViewController生命周期">第6讲 多重MVC 转场 ViewController生命周期</h1><ul>
<li>转场类型：<code>Show</code>导航或者模式视图 <code>Show Detail</code>split view或者导航 <code>Modal</code>模式 <code>Popover</code>弹出式</li>
<li>转场会创建新的MVC实例</li>
<li>用代码执行转场：<code>performSegueWithIdentifier</code></li>
<li>转场前的预操作：<code>prepareForSegue</code>。<strong>注意：此时所有的Outlet都还没有挂载，无法对它们进行配置；要对它们进行配置，最好放到viewDidLoad里面</strong></li>
<li>可以用代码判断是否真的进行转场：<code>shouldPerformSegueWithIdentifier</code></li>
<li>ViewController的生命周期：<ul>
<li>创建</li>
<li>如果是转场进入的，执行转场前的准备</li>
<li>设置Outlet，设置完成后进入<code>viewDidLoad</code>，在这里完成大部分对Outlet的设置</li>
<li>显示/不显示，覆盖相应方法 <code>viewWillAppear</code> <code>viewDidAppear</code> <code>viewWillDisappear</code> <code>viewDidDisappear</code>。会被频繁调用，不要做太多事情</li>
<li>几何形状变更, 会更新所有子View的布局，覆盖相应方法 <code>viewWillLayoutSubviews</code> <code>viewDidLayoutSubviews</code>。这两个方法实际会频繁被调，不要在这里做太多的事情<br>  <code>viewWillTransitionToSize</code> 处理旋转</li>
<li>低内存状态。<code>didReceiveMemoryWarning</code> 在这里释放一些大的资源(指针指向nil)</li>
</ul>
</li>
<li>设置Entry point:直接移动箭头，或者勾选<code>Is Initial View Controller</code></li>
<li>demo使用的View架构：<br>  split view<pre><code><span class="string">|- master - (navigation - content)</span>
<span class="string">|- detail - (navigation - content)</span>
</code></pre>  转场从content到content<br>  demo在转场中判断目标是不是navigation，并根据结果进行处理让目标View指向content</li>
<li>demo中通过打印显示了View架构的生命周期</li>
</ul>
<h1 id="第7讲_闭包_扩展_协议_代理_ScrollView">第7讲 闭包 扩展 协议 代理 ScrollView</h1><ul>
<li>ARC自动引用计数，三种<code>strong</code>正常引用 <code>weak</code>如果没有其它引用，把自己置为nil <code>unowned</code>不计入引用计数，如果对象为nil，程序崩溃</li>
<li>闭包会产生内存循环，可以用两种方法打破：<ul>
<li><code>[unowned self] in ...</code> 闭包中使用<code>self.xxx</code>,但是如果self为nil，程序会崩溃</li>
<li><code>[weak weakSelf = self] in ...</code> 闭包中使用<code>weakSelf?.xxx</code>，self为nil，语句会被跳过。<strong>注意:使用weakSelf是为了提醒作者注意这是个weak型？？</strong></li>
</ul>
</li>
<li>扩展：不能重新实现已有的方法和属性，只能添加新的；添加的属性不能有存储值，只能是计算属性</li>
<li>不要滥用扩展，只在必要时加入小的，自我完备的辅助方法</li>
<li>协议，参考<a href="/2016/06/21/Swift语言学习/index.html">Swift语言学习</a></li>
<li>代理是协议的一种重要形式</li>
<li>如何使用代理：<br>  控制器声明自己实现了某个代理<br>  控制器将View.delegate指向自己<br>  控制器实现具体的代理方法</li>
<li><code>ScrollView.contentSize</code>指定View内容的大小，子View按这个frame的坐标添加。加载完子View后<strong>一定要记得设置这个参数</strong></li>
<li><code>ScrollView.contentOffset</code>返回当前场景左上角位于View内容的哪个坐标</li>
<li><code>convertRect(scrollView.bounds, fromView:scrollView)</code>将当前显示区域转化到View内容框架坐标下？？</li>
<li><code>scrollRecttoVisible</code> 将区域设为显示区域？？</li>
<li>其它可用方法：是否可卷动，卷动方向锁定，卷动指示器（<code>flashScrollIndicators</code>）, 实际内容是否在内容区域中（<code>contentInset</code>）</li>
<li>缩放：<ul>
<li>要设置最小/最大缩放比例<code>minimumZoomScale</code> <code>maximumZoomScale</code></li>
<li><code>viewForZoomingInScrollView</code>实现该代理方法以返回支持缩放的View</li>
<li>缩放方法：<code>zoomScale</code> <code>setZoomScale</code> <code>zoomToRect</code></li>
<li><code>scrollViewDidEndZooming</code>代理方法，缩放结束后的处理</li>
</ul>
</li>
<li><code>ImageView</code>使用<code>sizeToFit</code>来适应图像大小</li>
</ul>
<h1 id="第8讲_多线程">第8讲 多线程</h1><ul>
<li>必须设置segue的标识。可以将多个segue的标识设成一样，然后通过sender来区别</li>
<li>使用<code>private struct</code>中的<code>static</code>值来保存标识符字串到常量中，以便引用和修改</li>
<li><p><code>Optional</code>链，第二个<code>?</code>使得<code>imageName</code>变成了<code>Optional</code>类型</p>
<figure class="highlight swift"><table><tr><td class="gutter"><pre><span class="line">1</span><br></pre></td><td class="code"><pre><span class="line"><span class="keyword">let</span> imageName = (sender <span class="keyword">as</span>? <span class="type">UIButton</span>)?.currentTitle</span><br></pre></td></tr></table></figure>
</li>
<li><p>可以在<code>UIView</code>的<code>didSet</code>中设置代理</p>
<figure class="highlight swift"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br></pre></td><td class="code"><pre><span class="line"><span class="keyword">didSet</span>&#123;</span><br><span class="line">	<span class="type">XXX</span>.delegate = <span class="keyword">self</span></span><br><span class="line">&#125;</span><br></pre></td></tr></table></figure>
</li>
<li><p>可以按住⌥再移动鼠标来模拟pinch效果</p>
</li>
<li>如果想使用Zoom, 不要忘了设置scrollView的最小和最大Zoom值</li>
<li>多线程，IOS的多线程就是创建或者获取各种<code>queue</code>，然后在不同的<code>queue</code>中放置<code>closure</code>，IOS自动执行</li>
<li>GCD(Grand Central Dispatch)</li>
<li>在其它队列中执行：<pre><code>let <span class="built_in">queue</span>: <span class="keyword">dispatch_queue_t</span> = 获取队列
dispatch_async(<span class="built_in">queue</span>){ <span class="comment">//分发</span>
    <span class="function">xxx
    <span class="title">dispatch_async</span><span class="params">(dispatch_get_main_queue()</span>)</span>{
    <span class="comment">//返回主队列执行异步操作</span>
    }
}
</code></pre>  <strong>注意：要想处理UI,必须像上面一样，在结尾分发回主队列</strong></li>
<li><code>main queue</code>用来执行UI相关的所有操作，其它<code>queue</code>用来执行非UI相关的操作</li>
<li><code>main queue</code>是一个序列化队列，不是并发队列</li>
<li>创建并发<code>queue</code>的方法<br>有4种优先级<ul>
<li>USER-INTERACTING</li>
<li>USER-INITIATED</li>
<li>UTILITY</li>
<li>BACKGROUD<br><code>let queue = dispatch_get_global_queue(ID,0)</code></li>
</ul>
</li>
<li>创建串行<code>queue</code>的方法<br>  <code>let queue = dispatch_queue_create(&quot;name&quot;, DISPATCH_QUEUE_SERIAL)</code></li>
<li>面向对象的API:<code>NSOperationQueue</code> <code>NSOperation</code><br>  函数方式的分发可读性强，面向对象的API在处理复杂的多线程时更好</li>
<li>放置<code>closure</code>的方法</li>
<li><p>检查是否处于显示状态</p>
<figure class="highlight swift"><table><tr><td class="gutter"><pre><span class="line">1</span><br></pre></td><td class="code"><pre><span class="line"><span class="keyword">if</span> view.window != <span class="literal">nil</span></span><br></pre></td></tr></table></figure>
</li>
<li><p><code>activity indicator view</code>要放置在正确的<code>superview</code>中</p>
</li>
<li><code>splitViewController</code> <code>collapseSecondaryViewController</code></li>
<li>重用<code>splitViewController</code>的方法，使用<code>target-action</code>,同时修改<code>NavigatorViewController</code>，使用<code>performSegueWithIdentifier</code>，需要注意这个<code>segue</code>是从<code>viewController</code>而不是控件发出的</li>
<li><code>UITextField</code>在iPhone上是次要的输入控件，因为键盘很小</li>
<li><code>UITextField</code>必须实现代理才有用</li>
<li>显示键盘:<code>becomeFirstResponder</code><br>  取消键盘：<code>resignFirstResponder</code></li>
<li><code>resignFirstResponder</code>最好放在<code>textFieldShouldReturn</code>中</li>
<li>使用<code>textFieldDidEndEditing</code>处理输入等</li>
<li><code>UITextField</code>也是控件，也支持<code>target-action</code></li>
<li>可以通过<code>UITextInputTraits</code>的<code>protocol</code>来控制键盘风格，注意无法直接操作键盘，只能与导致键盘弹出的控件进行对话</li>
<li>可以使用<code>UIKeyboard{Will,Did}{Show,Hide}Notification</code>来检查键盘的<code>notification</code>并插入处理代码</li>
<li><code>UITextField</code>还有其它属性，还支持文字的左到右/右到左显示</li>
<li>键盘上面可以显示辅助视图，通过设置<code>inputAccessoryView</code>来实现</li>
</ul>
<h1 id="第9讲_TableView">第9讲 TableView</h1><ul>
<li><code>TableView</code>有两种风格：<code>Plain</code>和<code>Grouped</code>，前者通常用于动态列表，后者通常用于静态列表</li>
<li><code>TableView</code>的构件：<code>Table Header</code>,<code>Table Footer</code>, <code>Section</code>。其中<code>Section</code>由<code>Header</code>，<code>Table Cell</code>和<code>Footer</code>组成。每一行的具体内容<code>Table Cell</code>是<code>UITableViewCell</code>??</li>
<li><code>Cell</code>风格有五种：<ul>
<li><code>Subtitle</code>:带一个小标题，小标题在上，内容在下</li>
<li><code>Basic</code>:只有内容</li>
<li><code>Right Detail</code>:小标题在左，内容在右</li>
<li><code>Left Detail</code>:与<code>Right Detail</code>类似，但是标题右对齐，内容左对齐</li>
<li>自定义内容</li>
</ul>
</li>
<li>使用<code>UITableViewController</code>来控制，<code>UITableViewController.view</code>是一个<code>UITableView</code><br>  控制器实现了View的代理和数据源<code>protocol</code></li>
<li><code>Ctrl+Shift+Click</code>可以从层叠的UI中选择</li>
<li><code>Proto Cell</code>:<code>Style</code> <code>Accessory</code>。如果选择<code>Custom</code>风格，必须将其指定到<code>UITableViewCell</code>的子类上</li>
<li><code>dataSource</code>代理控制数据，<code>delegate</code>代理控制显示</li>
<li><code>dataSource</code>控制动态数据，有三个重要的方法<ul>
<li><code>numberOfSectionsInTableView</code> 表里有多少<code>Section</code>。如果不实现，默认<code>Section</code>是1</li>
<li><code>tableView(sender: UITableView, numberOfRowsInSection: Int) -&gt;Int</code> 每个<code>Section</code>有多少行</li>
<li><code>tableView(tv, cellForRowAtIndexPath indexPath)-&gt;UITableViewCell</code> 指定<code>Section</code>的指定<code>Row</code>的<code>View</code>如何绘制</li>
<li><code>tableView(titleFor{Header,Footer}InSection)</code> 绘制指定<code>Row</code>的标题<br>其它方法未提及，自行查看</li>
</ul>
</li>
<li><code>⌃+drag</code>拖动行的原型到指定View，来设定点击行的转场</li>
<li>跳转到行的详细显示View前，实现<code>prepareForSegue</code>来进行数据准备</li>
<li><code>indexPathForCell</code>获取当前cell的索引，包括<code>.section</code> <code>.row</code></li>
<li><code>tableView(didSelectRowAtIndexPath)</code>行被选中时调用</li>
<li><code>tableView(accessoryButtonTappedForRowWithIndexPath)</code>行的详情按钮被点击时调用</li>
<li>其它代理方法：<ul>
<li>选中/取消选中的will,did</li>
<li>绘制section头和脚的UIView</li>
<li>处理编辑行行为，移动行行为</li>
<li>编辑的<code>willBegin</code> <code>didEnd</code></li>
<li>复制/粘贴行</li>
</ul>
</li>
<li><code>reloadData()</code> 重新根据数据计算table<br>  <code>reloadRowsAtIndexPaths</code> 重新计算table的部分内容</li>
<li>行高：<ul>
<li>固定式 <code>rowHeight</code></li>
<li>自动布局 <code>UITableViewAutomaticDimension</code></li>
<li>用代理计算 <code>tableView({estimated}heightForRowAtIndexPath)</code></li>
</ul>
</li>
<li><code>UITableView</code>是<code>UIScrollVIew</code>的子类</li>
<li>如果需要使用<code>framework</code>，需要建立一个<code>Workspace</code>把相应的<code>framework</code>和<code>project</code>包含进去</li>
</ul>
<h1 id="第10讲_Core_Data">第10讲 Core Data</h1><ul>
<li>可以以图形化的方式建立数据库，新建一个<code>Data Model</code>文件</li>
<li>数据库的内容以<code>NSNumber</code> <code>NSData</code> <code>NSString</code> <code>NSDate</code>的形式保存，但是swift可以直接转型使用</li>
<li>获取数据库存储文件的方法有两种：一种是在建立项目时选择<code>Use Core Data</code>，然后通过<code>AppDelegate</code>的<code>UIManagedDocument</code>获取文件；一种是使用文件管理自己创建一个数据库存储文件，然后用该文件的URL创建<code>UIManagedDocument</code></li>
<li><code>documentState</code>:<code>.Normal</code>直接操作 <code>.Closed</code>需要打开或者创建<br>  通过检查<code>fileExistsAtPath</code>来确定是打开(<code>openWithCompletionHandler</code>)或者创建（<code>saveToURL(.ForCreating)</code>）<br>  <code>.SavingError</code> 完成句柄中的sucess会是false<br>  <code>.EditingDisabled</code> 暂态，再尝试一次<br>  <code>.InConflict</code> 文件有冲突</li>
<li>用<code>insertNewObjectForEntityForName</code>将数据插入数据库。如果没有设置默认值，那么值都是<code>nil</code>。<code>Insertnewobjectforentityforname</code></li>
<li>可以用<code>valueForKey</code> <code>setValue</code>访问数据<br>  用<code>valueForKeyPath</code> <code>setValue(forKeyPath)</code>访问关系数据<br>  但是它们没有类型检查，而且需要很多字串做为键。<br>  更好的方法是使用类变量的setter/getter</li>
<li><code>UIManagedDocument</code>会自动保存，但是用其它方法获取的数据库不会自动保存，比如通过<code>AppDelegate</code>获取的文档，需要显式调用<code>save()</code>。</li>
<li><code>saveToURL(.ForOverwriting)</code>用来保存文档，该方法属于UIKit,只能在主队列中调用。通常<code>UIManagedDocument</code>会自动保存</li>
<li><code>closeWithCompletionHandler</code>用来关闭文档。通常在没有强引用的情况下文档会自动关闭</li>
<li><code>save()</code>会抛出异常, 使用<code>do{try{}}catch let error{}</code>来处理。如果确定不会抛出异常，可以使用<code>try! xxx</code>来处理，这种情况下一旦出现异常就会崩溃。或者使用<code>try? xxx</code>，一旦查询出异常，返回<code>nil</code></li>
<li>自定义异常通常是实现了<code>ErrorType</code>协议的枚举类型</li>
<li>属性有关联的情况，删除的规则可以通过图形化的方式指定，删除过的对象不要再继续用<code>strong</code>变量去引用</li>
<li>可以用<code>prepareForDeletion()</code>在删除前做操作</li>
<li>使用<code>NSFetchRequest</code>来设置查询。<code>NSPredicate</code>指定查询条件，<code>NSSortDescriptor</code>指定查询结果的排序</li>
<li><code>NSPredicate</code>中用<code>%@</code>而不是<code>\()</code>来表示表达式，更加类似printf</li>
<li><code>NSCompoundPredicate</code>可以指定复合查询条件</li>
<li>数据库表达式有<code>@count</code> <code>@avg</code>等，查看<a href="https://developer.apple.com/library/ios/documentation/cocoa/conceptual/KeyValueCoding/Articles/CollectionOperators.html" target="_blank" rel="external">苹果参考手册</a><br>  还可以使用<code>NSExpression</code>进行更复杂的条件查询</li>
<li>查询返回一个<code>NSManagedObjects</code>的数组，<strong>如果没有查询到结果，数组是空数组，而不是返回<code>nil</code></strong>。</li>
<li>查询返回的结果，只有在用户真正访问其属性时，才会真正访问数据库</li>
<li>所有对<code>NSManagedObjects</code>或者<code>NSManagedObject</code>的操作都要放到<code>performBlock</code>中，以保证线程安全性。</li>
<li>使用<code>NSFetchedResultsController</code>把数据和<code>UITableView</code>直接联系起来<ul>
<li><code>sections</code></li>
<li><code>objectAtIndexPath</code></li>
<li><code>controller(forChangeType)</code>用来监测Core Data的变化</li>
</ul>
</li>
</ul>
<h1 id="第11讲_Core_Data_Demo">第11讲 Core Data Demo</h1><h1 id="第12讲_AutoLayout">第12讲 AutoLayout</h1><ul>
<li>获取自身的<code>Size Class</code>:<br>  <code>self.traitCollection.horizontalSizeClass</code><br>  返回值是<code>.Regular</code>或者<code>.Compact</code></li>
<li><code>SplitView</code>的<code>MasterView</code>的宽度是<code>Compact</code>，但是要注意在<code>Portrait</code>模式下拉出来的<code>MasterView</code>不是<code>Compact</code>(那么是？？？)</li>
<li>Size分类：<ul>
<li>compact width, compact height: 普通iPhone, Landscape</li>
<li>compact width, regular height: 普通iPhone, Portrait, 或者split view的master</li>
<li>regular width, compact height: iphone6+, Landscape</li>
<li>regular width, regular height: iPad</li>
</ul>
</li>
</ul>
<h1 id="第13讲_定时器和动画">第13讲 定时器和动画</h1><ul>
<li><code>NSTimer</code>不是实时的</li>
<li>用<code>weak</code>引用<code>NSTimer</code>，这样每次<code>invalidate()</code>后它就会从堆中移除</li>
<li><code>NSTimer</code>的<code>tolerate</code>是不会传递给下一次循环的？？</li>
<li><code>scheduledTimerwithTimerInterval</code>中的<code>Selector</code>必须是<code>Object-C</code>兼容的，即<code>@objc</code>。但是swift的<code>private</code>函数无法识别，必须至少改成<code>internal</code>，或者在前面加上<code>@objc</code></li>
<li><code>Animation</code>包括<code>UIView</code>属性动画，<code>UIViewController</code>转场动画，<code>Core Animation</code>动画(通常用Layer实现)，<code>OpeGL</code> 3D, <code>SpriteKit</code> 2.5D, <code>Dynamic Animation</code> 基于物理引擎的<code>View</code>动画，支持力场和碰撞等</li>
<li>使用<code>animateWithDuration</code>进行<code>UIView</code>的动画。<code>animateWithDuration</code>的执行是立即的，会立即改变参数，仅仅是把结果渐渐地<strong>显现</strong>出来</li>
<li>常用参数：<code>beginWithCurrentState</code> 采用当前动画执行到的值做为起始值<br>  <code>AllowUserInteraction</code> 动画过程中支持用户操作<br>  <code>CaseXXX</code> 调整动画均匀度<br>  <code>TransitionXXX</code> 转场动画</li>
<li><code>transitionWithView</code> 使用闭包做为转场动画<br>  <code>transitionFromView</code> 从一个<code>View</code>转到另一个<code>View</code>，如果使用了<code>ShowHideTrasitionViews</code>属性，会隐藏<code>View</code>，否则会将<code>View</code>从整个继承结构中删除</li>
<li><code>lazy var</code>只有当被调用时才初始化，而且在未初始化时是不允许被调用的。</li>
<li><code>UIView</code>通过<code>layoutSubViews</code>来对子视图进行布局</li>
<li><code>View</code>的动画最好放在参数的<code>set</code>中进行，而不是<code>didSet</code></li>
<li><code>CGAffineTransformRotate</code></li>
<li>所有的动画都是独立进行的，除非它们操作同一个属性</li>
<li>用<code>completion</code>来制作动画链</li>
<li><code>Dynamic Animation</code>：首先创建<code>UIDynamicAnimator</code>然后添加<code>UIDynamicBehaviors</code>最后添加<code>UIDynamicItems</code>（通常是各种<code>UIView</code>）</li>
<li>创建<code>UIDynamicAnimator</code>指定顶级View<code>referenceView</code></li>
<li>创建并添加力场，再给不同的力场添加<code>UIDynamicItems</code>。</li>
<li><code>updateItemUsingCurrentState</code></li>
<li>力场：<ul>
<li><code>UIGravityBehavior</code> 重力</li>
<li><code>UIAttachmentBehavior</code> 链接</li>
<li><code>UICollisionBehavior</code> <code>.Item</code> <code>.Boundaries</code> <code>.Everything</code><br>  <code>translatesReferenceBoundsIntoBoundary</code><br>  检测碰撞用<code>UICollisionBehaviorDelegate</code>, <code>NSCopying</code>??</li>
<li><code>UISnapBehavior</code></li>
<li><code>UIPushBehavior</code> 瞬时力场</li>
<li><code>UIDynamicItemBehavior</code> 元力场，可以自定义</li>
<li>使用代理<code>UIDynamicAnimatorDelegate</code>检查力场是否达到稳定状态。<br>  <code>dynamicAnimatorDidPause</code>和<code>dynamicAnimatorWillResume</code></li>
</ul>
</li>
<li>力场闭包中引用力场本身会导致内存循环，需要设法解决：<pre><code><span class="keyword">pushBehavior.action </span>= {[unowned <span class="keyword">pushBehavior] </span>in
    <span class="keyword">pushBehavior.XXXX
</span>}
</code></pre></li>
</ul>
<h1 id="第14讲_动画和运动检测">第14讲 动画和运动检测</h1><ul>
<li><code>let XXX = {}()</code>可以用一个闭包给值赋值</li>
<li>创建一个新类，用<code>addChildBehavior</code>来产生复合力场效果</li>
<li>有两种方法操作<code>Core Motion</code>，轮询或者设置计时器+闭包</li>
<li>检查：<code>XXXAvailabe</code><br>  开始：<code>startXXXUpdates</code><br>  检查是否工作中：<code>XXXActive</code><br>  结束：<code>stopXXXUpdates</code><br>  获取数据：<code>XXXData</code></li>
<li>加速传感器：x屏幕水平，y屏幕垂直，z指向背面。以g为单位，静止时是1个g</li>
<li>陀螺仪：以弧度为单位，有<code>bias</code></li>
<li>指南针：</li>
<li><code>CMDeviceMothion</code>支持加速度<code>gravity</code>,考虑陀螺仪的加速度<code>userAcceleration</code>,不考虑<code>bias</code>的旋转速度<code>rotationRate</code>，3d方向<code>attitude</code>(<code>.roll</code> <code>.pitch</code> <code>.yaw</code>),指南针<code>magneticField</code></li>
<li>用<code>UIDevice.currentDevice().orientation</code>获取设备的方向,一共六种</li>
<li><code>swap(&amp;dx,&amp;dy)</code>??</li>
<li>锁定自动旋转后，旋转设备会改变方向；不锁定时，旋转设备会改变布局，不会改变方向??\</li>
</ul>
<h1 id="第15讲_App生命周期_告警_CloudKit">第15讲 App生命周期 告警 CloudKit</h1><ul>
<li><code>Notification</code>可以用于全局的通知，比代理的通知范围更广</li>
<li><code>alert</code>可以用于异步通知</li>
<li><code>alert</code>和<code>actionView</code>十分类似。<code>alert</code>在iPad和iPhone上基本一致；<code>actionView</code>在iPad上需要指定一个<code>BarButton</code>并在右上角显示，在iPhone上是在下方向上弹出</li>
<li><code>alert</code>对话框可以添加一个文本框<code>addTextFieldWithConfigurationXXX</code></li>
<li><code>Cloud Kit</code>是云数据库，要使用需要在项目的<code>Capabilities</code>中勾选</li>
<li><code>Cloud Kit</code>的表结构可以动态创建？？</li>
<li><code>Cloud Kit</code>支持<code>shared Container</code>，可以让多个App共享同一个服务器。<code>default Container</code>只限一个App使用，包含一个公共数据库和一个私有数据库，公共数据库可以让所有用户看到，私有数据库只有该用户登录<code>iCloud</code>后自己能看到</li>
<li><code>CKReference</code>相当于<code>Core Data</code>的关系</li>
<li><code>CKAsset</code>用来存储大文件，<code>CLLocation</code>用来存储地理位置</li>
<li><code>SaveRecord</code>返回的有些Error支持Retry并提供一个Retry Interval, 可以dispatch到mainQueue并通过NSTimer去重试</li>
<li><code>Query</code>的时候指定<code>Field name</code>为<code>self</code>就是在所有域进行搜索</li>
<li>除了<code>Created by``Created Time</code>，其它域在自动添加时都自动打开<code>Query</code>选项。注意未打开<code>Query</code>选项的域无法进行查找，为了提升效率，不必进行查找的域都应该关闭<code>Query</code>选项</li>
<li>获取用户ID,<code>fetchUserRecordID</code></li>
<li><code>CKReference</code>的<code>.DeleteSelf</code>意味着删除时不删除关系另一边的记录，<code>.None</code>则会级联删除</li>
</ul>
<h1 id="第16讲_CloudKit和提醒">第16讲 CloudKit和提醒</h1><ul>
<li>可以指定公共变量为非Optional,然后指定一个私有变量为Optional。让公共变量通过私有变量计算得到。这样做可以保持对外API要求必须为有效值，而对内可以保持为Optional<pre><code><span class="variable"><span class="keyword">var</span> xxx</span>:Type{
    <span class="keyword">get</span>{<span class="keyword">if</span> _xxx==nil{}
        <span class="keyword">return</span> _xxx}
    <span class="keyword">set</span>{_xxx=newValue}
    }
<span class="keyword">private</span> <span class="variable"><span class="keyword">var</span> _xxx</span>:Type?
</code></pre></li>
<li>CloudKit,<code>NSPredicate</code>用”TRUEPREDICATE”来表示查询所有</li>
<li>一行获取TableView所在行<br>  <code>if let cell = sender as? UITableViewCell, let indexPath = tableView.indexPathForCell(cell)</code></li>
<li><code>canEditRowAtIndexPath</code></li>
<li><code>commitEditingStyle</code>可以支持删除操作：<code>if editingStyle == .Delete</code></li>
<li><code>CKSubscription</code>,<code>saveSubscription</code> <code>CKErrorCode.ServerRejectedRequest</code>说明数据库中已经有了这个Subscription</li>
<li>在<code>AppDelegate</code>中注册<code>Notification</code><br>  在<code>didReceiveRemoteNotification</code>中处理，创建Notification，将收到的提醒分发给自己的所有View<br>  在需要接受提醒的ViewController中注册观察者<code>NSNotificationCenter.defaultCenter().addObserverForName</code></li>
<li>通过<code>queryNotificationReason</code>查看为什么提醒</li>
</ul>
<h1 id="第17讲_转场，Core_Location,_MapKit">第17讲 转场，Core Location, MapKit</h1><ul>
<li><code>func performSegueWithIdentifier</code> 显示一个模式VC<br>  <code>func presentViewController</code> 如果持有VC，显示该模式VC的方法</li>
<li>在水平宽度是<code>regular</code>的情况下，用<code>modalPresentationStyle</code>指定显示方式：<code>.FullScreen</code> <code>.OverFullScreen</code> <code>.Popover</code> <code>.FormSheet</code>等等<br>  在水平宽度是<code>compact</code>的情况下，只会以<code>FullScreen</code>形式显示</li>
<li>跳转前：<code>prepareForSegue</code><br>  回跳：<code>dismissViewControllerAnimated</code> <strong>注意这个是在转场前VC中定义，而不是在模式VC中</strong><br>  可以通过模式VC的<code>presentingViewController</code>来调用<br>  unwind转场会自动跳转，不需要调用dismiss</li>
<li>回跳时可以通过指定<code>modalTransitionStyle</code>来指定动画<code>.CoverVertical</code> <code>.FlipHorizontal</code> <code>.CrossDissolve</code> <code>.PartialCurl</code></li>
<li>unwind回跳只会跳到已存在的VC,不会创建新的VC;通常用于模式VC返回，或者导航模式一下一次性向回跳转多个VC</li>
<li>创建unwind segue:把Storyboard中的VC上的<code>Exit</code>拉向自己，然后选择一个其它VC中已经实现的特定<code>@IBAction</code>,所有转场父VC中标记为<code>@IBAction</code>并且只有唯一参数<code>UIStoryboardSegue</code>的方法都会出现在列表中，供选择</li>
<li>unwind segue选定后，同样可以在模式VC中定义<code>prepareForSegue</code></li>
<li>popover使用<code>UIPopoverPresentationController</code><br>  在其中通过<code>permittedArrowDirections</code>等参数进行设置<br>  还可以指定自己做为代理</li>
<li>popover的代理包括<ul>
<li><code>didDismissed</code> </li>
<li><code>adaptivePresntationStyle</code> 需要返回要用的VC,比如如果嵌入到导航中就返回导航页面</li>
<li><code>preferredContentSize</code> 可以覆盖并提供自定义的Size</li>
</ul>
</li>
<li>用<code>Container View</code>实现嵌入式View。同样通过<code>prepareForSegue</code>实现转场前的准备，但是同样的，调用时所有的控件都还没有挂载，无法配置。</li>
<li><code>Core Location</code>是UI无关的，基本对象是<code>CLLocation</code></li>
<li><code>coordinate</code> 坐标 <code>alttitude</code> 海拔<br>  <code>horizontal/verticalAccuracy</code> 精度<br>  <code>Speed</code> 大致速度  <code>course</code> 方向 <code>timestamp</code> 时间戳</li>
<li>位置精度由三种方式确定：基站定位(粗，省电)，Wifi节点(精，费电)，GPS（最精，最费电）。都是在后台控制，用户无法控制，只能指定精度等级</li>
<li>可以使用GPX文件来指定测试用路点</li>
<li>使用<code>CLLocationManager</code>来获取位置信息</li>
<li>使用地理信息的几种方式：持续接收，需要时获取，进入区域时获取，变换方向时获取</li>
<li><code>authorizationStatus</code>为<code>.Restricted</code>时，用户无法修改权限，只能放弃定位功能，在做界面时要注意区别</li>
<li><code>requestWhenInUseAuthorization</code> 询问用户当软件激活时是否允许使用定位<br>  <code>requestAlwaysAuthorization</code> 询问用户是否允许一直使用定位<br>  在询问完成之前，权限都是未确定<br>  要使用询问功能，必须在<code>Info.plist</code>中添加对应项:<br>  <code>NSLocationWhenInUseUsageDescription</code><br>  <code>NSLocationAlwaysUsageDescription</code></li>
<li>基于精度连续监测时，注意设置合适的<code>desiredAccuracy</code>和<code>distanceFilter</code></li>
<li>手动启停：<code>startUpdatingLocation</code> <code>stopUpdatingLocation</code></li>
<li>获取通知：<code>locationManager(, didUpdateLocations:[CLLocation])</code></li>
<li>基于方向的测量：<code>CLHeading</code>有很类似的API</li>
<li>错误处理：<code>locationManager(didFailWithError)</code>向代理报告错误<br>  <code>KCLErrorLocationUnknown</code> 可能是暂时状态，等一等<br>  <code>KCLErrorDenied</code> 用户不允许接收更新<br>  <code>KCLErrorHeadingFailure</code> 本地磁场干扰，等一等</li>
<li>获取地址可以在后台进行，但需要特别谨慎。可以用显著位置通知，或者用CLLocationManager的代理来代替</li>
<li>显著位置通知：<code>startMonitoringSignificantLocationChanges</code> <code>stopXXX</code><br>  通常使用基站定位法，注意在不使用的时候关掉</li>
<li>在<code>application(didFinishLaunchingWithOptions)</code>中创建一个<code>CLLocationManager</code>,然后通过它获取地址 ？？</li>
<li>基于区域的位置监测：<code>start/stopMonitoringForRegion</code><br>  创建区域 <code>CLCircularRegion(center,radius,identifier)</code><pre><code><span class="escape">`C</span>LBeaconRegion<span class="escape">`可</span>以用来创建信标区域
</code></pre>  代理的通知 <code>locationManager(didEnterRegion)</code> <pre><code>`<span class="function"><span class="title">locationManager</span><span class="params">(didExitRegion)</span></span>`
`<span class="function"><span class="title">locationManager</span><span class="params">(monitoringDidFailForRegion)</span></span>`
</code></pre></li>
<li>区域保存在<code>CLLocationManager</code>的<code>monitoredRegions</code>中，在程序外可以存续，通过id来访问<br>  可以获取最大区域监测范围<code>maximumRegionMonitoringDistance</code>，区域范围不要超过它，如果得到的是负值，说明区域监测不工作</li>
<li>信标区域 <code>startRangingBeaconsInRegion</code> 代理方法<code>locationManager(didRangeBeacons)</code>返回信标对象。信标对象给出接近程度</li>
<li>使用信标需要用UUID标志，参考<code>Core Bluetooth</code>框架的<code>CBPerpheralManager</code></li>
<li><code>MKMapView</code>显示地图</li>
<li>MapKit支持注释，注释中包括坐标，标题和子标题，用<code>MKAnnotationview</code>显示</li>
<li>注释有一个callout，点击时显示；callout还可以指定左边和右边的辅助视图</li>
<li>Map的<code>annotations</code>属性是只读的，需要用<code>add/removeAnnotations(s)</code>来操作，不能直接操作属性</li>
<li><code>MKAnnotation</code>是协议，任何东西都可以实现这个协议</li>
<li>最好一次性预先加载所有注释。</li>
<li><code>canShowCallout</code>指定会不会出现callout<br>  <code>didSelectAnnotationView</code>在这里对callout进行主要的初始化，比如加载辅助视图</li>
<li><code>dequeueReusableAnnotationViewWithIdentifier</code>??</li>
<li><code>MKAnnotationView</code>的一些属性<br>  <code>annotaion</code><br>  <code>image</code> 代替默认的pin图形<br>  <code>left/rightCalloutAccessoryView</code><br>  <code>enabled</code> 是否支持点击<br>  <code>centerOffset</code> 针头在pin图形的什么位置<br>  <code>draggable</code> 是否支持拖放。要想工作必须先把<code>coordinate</code>属性改成读写</li>
<li>如果设置callout的辅助窗是<code>UIControl</code>，那么<code>mapView(calloutAccessoryConrolTapped)</code>就可以使用，可以在这里设置手动转场</li>
<li>设置地图类型<code>mapType</code><br>  显示用户位置<code>showsUserL</code> <code>isUserLVisible</code> <code>userL</code><br>  限制用户操作 <code>zoom/scroll/pitch/rotateEnabled</code></li>
<li>摄像头操作 <code>camera: MKMapCamera</code> 用于3D地图，指示用户视角</li>
<li>控制显示的范围：<code>region:MKCoordinateRegion</code> 指定原点和范围<br>  <code>setRegion</code>动画设置范围<br>  可以直接指定原点 <code>centerCoordinate</code> <code>setCenterCoordinate</code> <code>showAnnotations</code></li>
<li><code>mapPoint/RectForPoint/Rect</code> <code>point/rectForMapPoint/Rect</code><br>  进行地图坐标和视图中的坐标之间的转换</li>
<li><code>didChangeRegionAnimated</code> 可以用来做链式动画</li>
<li><code>MKMapView</code> view == nil 与TableView类似，但是故事板中没有原型单元，只能在代码中创建？？</li>
<li>查找地址 <code>MKLocalSearchRequest</code><br>  <code>MKLocaolSearch</code>实例的<code>startWithCompletionHandler</code><br>  最终返回<code>MKLocalSearchResponse</code>,包括一组<code>MKMapItem</code><br>  可以在<code>openInMapsWithLaunchOptions</code>中打开返回的对象</li>
<li>animate？？</li>
<li>Directions<br>  与地址查找类似，定义源和目的的MKMapItem，然后用异步API获取<code>MKRoute</code>,其中包括名字，转向，预期花费时间等；还有<code>MKPolyline</code>可以在地图上显示</li>
<li>Overlays<br>  <code>addOverlay(level)</code> <code>removeOverlay</code><br>  <code>MKOverlay</code>协议，包括注释，<code>boundingMapRect</code> <code>intersectsMapRect</code><br>  代理方法：<code>mapView(rendererForOverlay:)</code><br>  内建的渲染器：<code>MKCircle/Polyline/Polygon/TileOverlayRenderer</code>,可以参考<code>MKShape</code></li>
<li>可以使用<code>NSURL</code>打开文件 </li>
<li>访问网络时要打开ATS</li>
</ul>
<h1 id="第18讲_持续化">第18讲 持续化</h1><ul>
<li><code>calloutAccessoryControlTapped</code></li>
<li>响应长按：使用长按手势识别器</li>
<li><code>convertPoint</code>将屏幕点转换成地图上的位置</li>
<li>给<code>GPX.Waypoint</code>实现<code>MKAnnotation</code>协议，达到适配的效果；覆盖了<code>coordinate</code>属性，使其可读写</li>
<li>设置<code>draggable</code>??</li>
<li><code>viewDidAppear</code>中添加通知，监听textField的输入变化<br>  <code>viewWillDisappear</code>中取消通知</li>
<li>使用unwind在回跳时更新信息</li>
<li>使用<code>Form Sheet</code>在IPad下输入信息，会更好看</li>
<li>popover需要指定<code>anchor</code>做为指向的View, 指定<code>sourceRect</code>为指向的区域</li>
<li>在<code>viewWillLayoutSubviews</code>中设定<code>preferredContentSize</code>,使用<code>systemLayoutSizeFittingSize</code>的参数：<br>  <code>ExpandedSize</code>尽量大； <code>CompressedSize</code>尽量小</li>
<li>使用<code>AutoLayout</code>的≥来保证控件的最小大小</li>
<li>popover显示半透明效果，将background设置成default</li>
<li>使用popoverVC的代理，然后在didDismiss中更新信息</li>
<li>使用<code>viewControllerForAdaptivePresentationStyle</code>处理在iPhone下自适应popover view导致的问题<br>  在<code>.FullScreen</code>下用代码添加导航VC</li>
<li>使用<code>.OverFullScreen</code>可以返回全屏模式View，而且不会覆盖下面的View</li>
<li><code>UIVisualEffectView</code>可以产生视觉效果<ul>
<li>指定frame等于目标View的bounds</li>
<li>指定<code>autoresizingMask = [.FlexibleWidth, .FlexibleHeight]</code></li>
<li>目标view<code>insertSubview(xxx, atIndex: 0)</code></li>
</ul>
</li>
<li><code>Persistence</code>的几种方式：<br>  <em>NSUserDefaults</em> 少量信息<br>  <em>Core Data</em><br>  <em>Archiving</em> 很少用到，但是故事板采用这种方式<br>  <em>SQLite</em> 很少用到，除非有遗留的SQL数据库<br>  <em>文件系统</em> Unix文件系统，有限制的读写</li>
<li>使用<code>NSCoding</code>协议来持久化对象图谱<br>  <code>encodeWithCoder</code> <code>init(coder: NSCoder)</code><br>  但是有更简单的持久化机制</li>
<li>文件系统：<ul>
<li>获取根路径 -&gt; 加上文件的子路径 -&gt; 读写</li>
<li>用<code>NSFileManager</code>处理文件 </li>
<li>app把IOS文件系统当作普通的Unix文件系统，根目录是<code>/</code>。但是app只能在自己的沙盒中操作</li>
</ul>
</li>
<li>沙盒包括<ul>
<li>app bundle目录，不能写</li>
<li>Documents，存储持久化数据的地方</li>
<li>Caches，存储临时文件 </li>
<li>其它目录，参考<code>NSSearchPathDirectory</code></li>
</ul>
</li>
<li>获取路径：<pre><code>let fileManager = <span class="function"><span class="title">NSFileManager</span><span class="params">()</span></span>
let urls:[NSURL] = fileManager.<span class="function"><span class="title">URLsForDirectory</span><span class="params">(目录类型,inDomain: NSUserDomainMask)</span></span>
</code></pre></li>
<li>创建路径：<br>  <code>URLByAppendingPathComponent/Extension</code></li>
<li>查询 <code>isFileURL</code>是不是文件URL<br>  <code>resourceValuesForKeys()</code>查询URL的详情，文件信息等</li>
<li>读写文件 <code>NSData</code>的<code>init?(contentsOfURL)</code> <code>writeToURL</code></li>
<li><code>NSFileManager</code>是线程安全的</li>
<li><code>createDirectoryAtURL</code>创建目录 <code>isReadableFileAtPath</code></li>
</ul>
<!--less-->

      
    </div>
    <footer class="article-footer">
      <a data-url="http://www.loongeek.com/2016/06/15/IOS学习笔记——斯坦福公开课笔记/" data-id="ciqdugqjn002uxvjhgwvfxbr2" class="article-share-link">Share</a>
      
      
  <ul class="article-tag-list"><li class="article-tag-list-item"><a class="article-tag-list-link" href="/tags/IOS/">IOS</a></li><li class="article-tag-list-item"><a class="article-tag-list-link" href="/tags/Xcode/">Xcode</a></li></ul>

      
	  	<a id="back-to-top" href="javascript:scroll(0,0);"><i class="icon" id="icon-angle-up"></i></a>
	  
    </footer>
  </div>
  
    
<nav id="article-nav">
  
    <a href="/2016/06/21/Swift语言学习/" id="article-nav-newer" class="article-nav-link-wrap">
      <strong class="article-nav-caption">Newer</strong>
      <div class="article-nav-title">
        
          Swift语言学习
        
      </div>
    </a>
  
  
    <a href="/2016/06/14/Git笔记/" id="article-nav-older" class="article-nav-link-wrap">
      <strong class="article-nav-caption">Older</strong>
      <div class="article-nav-title">Git笔记</div>
    </a>
  
</nav>

  
</article>
</section>
        
          <aside id="sidebar">
  
    
  <div class="widget-wrap">
    <h3 class="widget-title">Categories</h3>
    <div class="widget">
      <ul class="category-list"><li class="category-list-item"><a class="category-list-link" href="/categories/CG/">CG</a><span class="category-list-count">1</span></li><li class="category-list-item"><a class="category-list-link" href="/categories/test/">test</a><span class="category-list-count">1</span></li><li class="category-list-item"><a class="category-list-link" href="/categories/其它/">其它</a><span class="category-list-count">1</span></li><li class="category-list-item"><a class="category-list-link" href="/categories/外语/">外语</a><span class="category-list-count">1</span></li><li class="category-list-item"><a class="category-list-link" href="/categories/未分类/">未分类</a><span class="category-list-count">1</span></li><li class="category-list-item"><a class="category-list-link" href="/categories/软件/">软件</a><span class="category-list-count">26</span></li></ul>
    </div>
  </div>

  
    
  <div class="widget-wrap">
    <h3 class="widget-title">Tags</h3>
    <div class="widget">
      <ul class="tag-list"><li class="tag-list-item"><a class="tag-list-link" href="/tags/3d/">3d</a><span class="tag-list-count">1</span></li><li class="tag-list-item"><a class="tag-list-link" href="/tags/C/">C</a><span class="tag-list-count">1</span></li><li class="tag-list-item"><a class="tag-list-link" href="/tags/English/">English</a><span class="tag-list-count">1</span></li><li class="tag-list-item"><a class="tag-list-link" href="/tags/HEXO/">HEXO</a><span class="tag-list-count">1</span></li><li class="tag-list-item"><a class="tag-list-link" href="/tags/Hexo/">Hexo</a><span class="tag-list-count">1</span></li><li class="tag-list-item"><a class="tag-list-link" href="/tags/IDE/">IDE</a><span class="tag-list-count">2</span></li><li class="tag-list-item"><a class="tag-list-link" href="/tags/IOS/">IOS</a><span class="tag-list-count">12</span></li><li class="tag-list-item"><a class="tag-list-link" href="/tags/KVO/">KVO</a><span class="tag-list-count">1</span></li><li class="tag-list-item"><a class="tag-list-link" href="/tags/Markdown/">Markdown</a><span class="tag-list-count">1</span></li><li class="tag-list-item"><a class="tag-list-link" href="/tags/Notification/">Notification</a><span class="tag-list-count">1</span></li><li class="tag-list-item"><a class="tag-list-link" href="/tags/Python/">Python</a><span class="tag-list-count">1</span></li><li class="tag-list-item"><a class="tag-list-link" href="/tags/SSH/">SSH</a><span class="tag-list-count">1</span></li><li class="tag-list-item"><a class="tag-list-link" href="/tags/Threading/">Threading</a><span class="tag-list-count">1</span></li><li class="tag-list-item"><a class="tag-list-link" href="/tags/Tuning/">Tuning</a><span class="tag-list-count">1</span></li><li class="tag-list-item"><a class="tag-list-link" href="/tags/UI-Test/">UI Test</a><span class="tag-list-count">1</span></li><li class="tag-list-item"><a class="tag-list-link" href="/tags/UML/">UML</a><span class="tag-list-count">1</span></li><li class="tag-list-item"><a class="tag-list-link" href="/tags/Unit-Test/">Unit Test</a><span class="tag-list-count">1</span></li><li class="tag-list-item"><a class="tag-list-link" href="/tags/WEB/">WEB</a><span class="tag-list-count">3</span></li><li class="tag-list-item"><a class="tag-list-link" href="/tags/Xcode/">Xcode</a><span class="tag-list-count">3</span></li><li class="tag-list-item"><a class="tag-list-link" href="/tags/blender/">blender</a><span class="tag-list-count">1</span></li><li class="tag-list-item"><a class="tag-list-link" href="/tags/git/">git</a><span class="tag-list-count">1</span></li><li class="tag-list-item"><a class="tag-list-link" href="/tags/java/">java</a><span class="tag-list-count">1</span></li><li class="tag-list-item"><a class="tag-list-link" href="/tags/java8/">java8</a><span class="tag-list-count">1</span></li><li class="tag-list-item"><a class="tag-list-link" href="/tags/lambda/">lambda</a><span class="tag-list-count">1</span></li><li class="tag-list-item"><a class="tag-list-link" href="/tags/misc/">misc</a><span class="tag-list-count">1</span></li><li class="tag-list-item"><a class="tag-list-link" href="/tags/networks/">networks</a><span class="tag-list-count">1</span></li><li class="tag-list-item"><a class="tag-list-link" href="/tags/stream/">stream</a><span class="tag-list-count">1</span></li><li class="tag-list-item"><a class="tag-list-link" href="/tags/swift/">swift</a><span class="tag-list-count">1</span></li><li class="tag-list-item"><a class="tag-list-link" href="/tags/swing-刷新/">swing 刷新</a><span class="tag-list-count">1</span></li><li class="tag-list-item"><a class="tag-list-link" href="/tags/test/">test</a><span class="tag-list-count">1</span></li><li class="tag-list-item"><a class="tag-list-link" href="/tags/小技巧/">小技巧</a><span class="tag-list-count">4</span></li><li class="tag-list-item"><a class="tag-list-link" href="/tags/并发/">并发</a><span class="tag-list-count">2</span></li><li class="tag-list-item"><a class="tag-list-link" href="/tags/插件/">插件</a><span class="tag-list-count">1</span></li><li class="tag-list-item"><a class="tag-list-link" href="/tags/网络/">网络</a><span class="tag-list-count">1</span></li></ul>
    </div>
  </div>

  
    
  <div class="widget-wrap">
    <h3 class="widget-title">Tag Cloud</h3>
    <div class="widget tagcloud">
      <a href="/tags/3d/" style="font-size: 10px;">3d</a> <a href="/tags/C/" style="font-size: 10px;">C</a> <a href="/tags/English/" style="font-size: 10px;">English</a> <a href="/tags/HEXO/" style="font-size: 10px;">HEXO</a> <a href="/tags/Hexo/" style="font-size: 10px;">Hexo</a> <a href="/tags/IDE/" style="font-size: 12.5px;">IDE</a> <a href="/tags/IOS/" style="font-size: 20px;">IOS</a> <a href="/tags/KVO/" style="font-size: 10px;">KVO</a> <a href="/tags/Markdown/" style="font-size: 10px;">Markdown</a> <a href="/tags/Notification/" style="font-size: 10px;">Notification</a> <a href="/tags/Python/" style="font-size: 10px;">Python</a> <a href="/tags/SSH/" style="font-size: 10px;">SSH</a> <a href="/tags/Threading/" style="font-size: 10px;">Threading</a> <a href="/tags/Tuning/" style="font-size: 10px;">Tuning</a> <a href="/tags/UI-Test/" style="font-size: 10px;">UI Test</a> <a href="/tags/UML/" style="font-size: 10px;">UML</a> <a href="/tags/Unit-Test/" style="font-size: 10px;">Unit Test</a> <a href="/tags/WEB/" style="font-size: 15px;">WEB</a> <a href="/tags/Xcode/" style="font-size: 15px;">Xcode</a> <a href="/tags/blender/" style="font-size: 10px;">blender</a> <a href="/tags/git/" style="font-size: 10px;">git</a> <a href="/tags/java/" style="font-size: 10px;">java</a> <a href="/tags/java8/" style="font-size: 10px;">java8</a> <a href="/tags/lambda/" style="font-size: 10px;">lambda</a> <a href="/tags/misc/" style="font-size: 10px;">misc</a> <a href="/tags/networks/" style="font-size: 10px;">networks</a> <a href="/tags/stream/" style="font-size: 10px;">stream</a> <a href="/tags/swift/" style="font-size: 10px;">swift</a> <a href="/tags/swing-刷新/" style="font-size: 10px;">swing 刷新</a> <a href="/tags/test/" style="font-size: 10px;">test</a> <a href="/tags/小技巧/" style="font-size: 17.5px;">小技巧</a> <a href="/tags/并发/" style="font-size: 12.5px;">并发</a> <a href="/tags/插件/" style="font-size: 10px;">插件</a> <a href="/tags/网络/" style="font-size: 10px;">网络</a>
    </div>
  </div>

  
    
  <div class="widget-wrap">
    <h3 class="widget-title">Archives</h3>
    <div class="widget">
      <ul class="archive-list"><li class="archive-list-item"><a class="archive-list-link" href="/archives/2016/07/">July 2016</a><span class="archive-list-count">10</span></li><li class="archive-list-item"><a class="archive-list-link" href="/archives/2016/06/">June 2016</a><span class="archive-list-count">9</span></li><li class="archive-list-item"><a class="archive-list-link" href="/archives/2016/04/">April 2016</a><span class="archive-list-count">2</span></li><li class="archive-list-item"><a class="archive-list-link" href="/archives/2016/01/">January 2016</a><span class="archive-list-count">3</span></li><li class="archive-list-item"><a class="archive-list-link" href="/archives/2015/12/">December 2015</a><span class="archive-list-count">5</span></li><li class="archive-list-item"><a class="archive-list-link" href="/archives/2015/07/">July 2015</a><span class="archive-list-count">2</span></li></ul>
    </div>
  </div>

  
    
  <div class="widget-wrap">
    <h3 class="widget-title">Recents</h3>
    <div class="widget">
      <ul>
        
          <li>
            <a href="/2016/07/08/IOS学习——KVO/">IOS学习——KVO</a>
          </li>
        
          <li>
            <a href="/2016/07/07/IOS性能调优笔记/">IOS性能调优笔记</a>
          </li>
        
          <li>
            <a href="/2016/07/07/IOS学习——Notification/">IOS学习——Notification</a>
          </li>
        
          <li>
            <a href="/2016/07/06/Blender基本操作笔记/">Blender基本操作笔记</a>
          </li>
        
          <li>
            <a href="/2016/07/06/IOS学习——并发编程-1/">IOS学习——并发编程</a>
          </li>
        
      </ul>
    </div>
  </div>

  
    
  <div class="widget-wrap">
    <h3 class="widget-title">About</h3>
    <div class="widget">
	mail: XXX
	Weibo:xxx
    </div>
  </div>


  
</aside>
        
      </div>
      <footer id="footer">
  
<div class="outer">
    <div id="footer-info" class="inner">
	<p>&copy; 2016 Loongeek</p>
    <p>Powered by <a href="http://hexo.io/" target="_blank">Hexo</a></p>
    </div>
  </div>
</footer>
    </div>
    <nav id="mobile-nav">
  
    <a href="/" class="mobile-nav-link">首页</a>
  
    <a href="/archives" class="mobile-nav-link">存档</a>
  
    <a href="/about" class="mobile-nav-link">关于</a>
  
</nav>
    

<script src="//ajax.googleapis.com/ajax/libs/jquery/2.0.3/jquery.min.js"></script>


  <link rel="stylesheet" href="/fancybox/jquery.fancybox.css" type="text/css">
  <script src="/fancybox/jquery.fancybox.pack.js" type="text/javascript"></script>


<script src="/js/script.js" type="text/javascript"></script>

  </div>
</body>
</html>